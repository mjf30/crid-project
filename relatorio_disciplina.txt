\documentclass[12pt, a4paper]{article}

% --- PACOTES ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{parskip} % Para espaçamento entre parágrafos em vez de indentação

% --- CONFIGURAÇÕES ---

% Margens da página
\geometry{a4paper, margin=2.5cm}

% Configuração de links
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

% Configuração dos blocos de código (listings)
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{customstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\small\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=customstyle}

% --- DOCUMENTO ---

\title{Relatório de Projeto de Disciplina: \\ Sistema de Verificação de Certificados com Blockchain}
\author{Seu Nome Completo \\ \texttt{seu.email@instituicao.com}}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Objetivo do Projeto}
Este relatório detalha o desenvolvimento de um sistema de prova de conceito para a verificação de autenticidade de Certificados de Registro de Inscrição em Disciplina (CRID). O objetivo foi utilizar a tecnologia blockchain para criar uma solução segura, descentralizada e eficiente, onde a validação de um certificado pudesse ser realizada por qualquer pessoa, sem a necessidade de consultar um banco de dados centralizado.

\section{Tecnologias Utilizadas}
A seleção de tecnologias foi orientada pela busca de ferramentas robustas e amplamente adotadas no ecossistema de desenvolvimento para Ethereum.

\subsection{Blockchain Ethereum}
Foi escolhida como a plataforma base por ser a principal rede com suporte a smart contracts (contratos inteligentes), possuindo uma vasta comunidade, documentação extensa e um ecossistema maduro de ferramentas de desenvolvimento.

\subsection{Solidity}
É a linguagem de programação padrão para escrever smart contracts na Ethereum Virtual Machine (EVM). Sua sintaxe é similar a C++ e JavaScript, e foi a escolha natural para a implementação da lógica do contrato.

\subsection{Hardhat}
Um ambiente de desenvolvimento para Ethereum que facilita todo o ciclo de vida do projeto. Foi utilizado para:
\begin{itemize}
    \item Compilar os contratos em Solidity.
    \item Executar uma rede Ethereum local para testes.
    \item Rodar testes automatizados escritos em JavaScript.
    \item Gerenciar a implantação (deploy) dos contratos.
\end{itemize}

\subsection{OpenZeppelin Contracts}
Uma biblioteca de smart contracts modulares, reutilizáveis e seguros. Foi utilizada para importar o contrato `Ownable.sol`, que implementa um sistema de controle de acesso simples e seguro, onde apenas um endereço (o "dono") tem permissões especiais. Isso foi fundamental para garantir que apenas a instituição de ensino (dona do contrato) pudesse emitir certificados válidos.

\subsection{GitHub Actions}
Ferramenta de Integração Contínua e Entrega Contínua (CI/CD) integrada ao GitHub. Foi usada para automatizar a execução dos testes a cada nova alteração no código, garantindo que a base de código se mantenha estável e que novas funcionalidades não quebrem o que já existia.

\section{Arquitetura e Implementação}
A principal decisão de arquitetura foi projetar um sistema que não armazenasse os dados dos certificados diretamente na blockchain, a fim de minimizar os custos de gás. A validação é feita através de assinaturas digitais.

\subsection{Fluxo de Verificação}
\begin{enumerate}
    \item \textbf{Geração Off-Chain:} A instituição de ensino (dona do contrato) gera os dados do certificado (ID do aluno, curso, etc.) em seu próprio sistema (off-chain).
    \item \textbf{Assinatura Off-Chain:} A instituição cria uma hash (resumo criptográfico) desses dados e a assina digitalmente com sua chave privada.
    \item \textbf{Distribuição:} O aluno recebe os dados do certificado e a assinatura digital correspondente.
    \item \textbf{Verificação On-Chain:} Para verificar o certificado, um terceiro (ex: um empregador) submete os dados do certificado e a assinatura para a função `verificarCertificado` no smart contract. O contrato então executa a verificação criptográfica para confirmar se a assinatura corresponde aos dados e se foi gerada pelo dono do contrato.
\end{enumerate}

\subsection{Smart Contract: \texttt{Crid.sol}}
O contrato é o núcleo do sistema. Sua função mais importante, `verificarCertificado`, é uma função do tipo `view`, o que significa que ela apenas lê o estado da blockchain e não o modifica. Isso torna sua chamada gratuita se feita a partir de um nó local, e muito barata se incluída em uma transação.

A função executa os seguintes passos:
\begin{enumerate}
    \item Recria a hash dos dados do certificado exatamente como foi feito off-chain.
    \item Adiciona o prefixo `\x19Ethereum Signed Message:\n32` à hash para garantir que a assinatura não possa ser usada em outro contexto.
    \item Usa a função `ecrecover` para extrair o endereço do assinante a partir da hash e da assinatura.
    \item Compara o endereço recuperado com o endereço do `owner` do contrato. A verificação só é bem-sucedida se os endereços forem idênticos.
\end{enumerate}

\begin{lstlisting}[language=Solidity, caption={Função principal de verificação no Crid.sol}]
function verificarCertificado(
    Certificado calldata _certificado,
    bytes calldata _assinatura
) public view returns (bool) {
    bytes32 messageHash = _getMessageHash(_certificado);
    bytes32 prefixedHash = _getEthSignedMessageHash(messageHash);
    address signer = _recoverSigner(prefixedHash, _assinatura);

    return signer != address(0) && signer == owner();
}
\end{lstlisting}

\subsection{Testes Automatizados}
Foi criada uma suíte de testes com Hardhat e Ethers.js para garantir a robustez do contrato. Os testes cobrem cenários críticos para validar a lógica de negócio:
\begin{itemize}
    \item \textbf{Caminho Feliz:} Testa se uma assinatura válida, gerada pelo dono do contrato, retorna `true`.
    \item \textbf{Assinatura Inválida:} Testa se uma assinatura corrompida ou malformada retorna `false`.
    \item \textbf{Assinante Incorreto:} Garante que uma assinatura gerada por outra conta que não seja a dona do contrato retorne `false`.
    \item \textbf{Dados Adulterados:} Verifica se os dados do certificado foram alterados após a assinatura, o que deve invalidar a verificação.
\end{itemize}

\subsection{Integração Contínua (CI)}
O workflow definido em `.github/workflows/ci.yml` automatiza a verificação do projeto. A cada `push` ou `pull request`, o GitHub Actions executa um job que realiza a compilação do contrato e roda toda a suíte de testes. Isso previne a integração de código com bugs no branch principal.

\begin{lstlisting}[language=YAML, caption={Workflow de CI com GitHub Actions}]
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    - name: Instalar dependencias
      run: npm ci
    - name: Compilar o contrato
      run: npx hardhat compile
    - name: Executar os testes
      run: npx hardhat test
\end{lstlisting}

\section{Como Executar o Projeto}
Para compilar e testar o projeto localmente, siga os passos:
\begin{enumerate}
    \item Clone o repositório e navegue até a pasta do projeto.
    \item Instale as dependências: \texttt{npm install}
    \item Compile o smart contract: \texttt{npx hardhat compile}
    \item Execute os testes: \texttt{npx hardhat test}
\end{enumerate}

\section{Conclusão}
O projeto demonstrou com sucesso a implementação de um sistema de verificação de certificados baseado em blockchain. A abordagem de assinaturas off-chain provou ser uma solução elegante e eficiente, garantindo segurança criptográfica sem os altos custos de armazenamento de dados on-chain. As ferramentas escolhidas, como Hardhat e GitHub Actions, foram essenciais para criar um fluxo de trabalho de desenvolvimento profissional e garantir a qualidade e a confiabilidade do smart contract.

\end{document}
